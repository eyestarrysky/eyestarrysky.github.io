<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>利用github和hexo快速搭建个人博客</title>
    <url>/2020/04/17/%E5%88%A9%E7%94%A8github%E5%92%8Chexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p><code>git</code>下载地址：<code>http://gitforwindows.org</code></p>
<h4 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><p> <code>node.js</code> 下载地址：<code>http://nodejs.org/en/</code> </p>
<h3 id="二、本地搭建"><a href="#二、本地搭建" class="headerlink" title="二、本地搭建"></a>二、本地搭建</h3><ul>
<li><p>选择一个文件夹建一个目录<code>blog</code>存放博客相关文件，文件夹内右键打开<code>git bash here</code>，在窗口中执行以下所有命令</p>
</li>
<li><p>用<code>npm</code>安装<code>hexo</code>，由于国内网络高“墙”深院，避免安装缓慢或失败，这里切换阿里的<code>NPM</code>镜像，没办法只能采用迂回战术了。</p>
</li>
</ul>
<pre><code class="sh">$ npm install -g cnpm --registry=http://registry.npm.taobao.org</code></pre>
<p>用 <code>cnpm</code> 安装 <code>hexo</code></p>
<pre><code class="sh">$ cnpm install -g hexo-cli
$ cnpm install hexo --save
##检查hexo是否安装成功
$ hexo -v</code></pre>
<ul>
<li>在<code>blog</code>文件夹建一个<code>hexo</code>文件存放博客，进入也打开<code>git bash here</code></li>
</ul>
<pre><code class="sh">$ hexo init</code></pre>
<p>初始化成功后，<code>hexo文件</code>夹内会出现如下的文件：</p>
<p><code>node_modules</code>: 依赖包<br><code>public</code>：存放生成的页面<br><code>scaffolds</code>：生成文章的一些模板<br><code>source</code>：用来存放你的文章<br><code>themes</code>：放下下载的主题<br><code>_config.yml:</code> 博客的核心配置文件（设置主体、标题等属性）</p>
<ul>
<li><p>接着需要执行一下<code>cnpm install</code>命令，要不下边的启动会提示命令不合法。</p>
</li>
<li><p>最后使用<code>hexo s -g</code>启动安装好的<code>hexo</code></p>
</li>
</ul>
<h3 id="三、托管至GitHub"><a href="#三、托管至GitHub" class="headerlink" title="三、托管至GitHub"></a>三、托管至GitHub</h3><ul>
<li><p>建立一个仓库，名称为<code>xxx.github.io</code></p>
</li>
<li><p>配置<code>_config.xml</code>文件，添加<code>GitHub</code>地址</p>
</li>
</ul>
<pre><code class="yml">deploy:
  type: git
  repo: https://github.com/xxx/xxx.github.io.git
  branch: master</code></pre>
<ul>
<li>安装部署命令<code>deploy-git</code> ，这样你才能用命令部署到<code>GitHub</code></li>
</ul>
<pre><code class="sh">$ cnpm install hexo-deployer-git  --save</code></pre>
<ul>
<li>安装好后，依次执行下列命令，提交本地<code>hexo</code>文件到<code>GitHub</code></li>
</ul>
<pre><code class="sh">$ hexo clean
$ hexo generate
$ hexo deploy</code></pre>
<ul>
<li>最后访问<code>https://xxx.github.io.git</code>即可</li>
</ul>
<h3 id="四、选择自己喜欢的主题"><a href="#四、选择自己喜欢的主题" class="headerlink" title="四、选择自己喜欢的主题"></a>四、选择自己喜欢的主题</h3><ul>
<li><p>到<code>http://hexo.io/themes/</code>下载主题，<code>git clone</code>到本地</p>
<p><code>git clone https://github.com/iissnan/hexo-theme-next</code></p>
</li>
<li><p>修改<code>hexo</code>文件夹下的<code>_config.yml</code>文件中的<code>theme</code>属性</p>
</li>
</ul>
<pre><code class="yml">theme: hexo-theme-next</code></pre>
<ul>
<li>再次打包上传即可<pre><code class="sh">$ hexo clean
$ hexo generate
$ hexo deploy</code></pre>
</li>
</ul>
<h3 id="五、Hexo基本操作"><a href="#五、Hexo基本操作" class="headerlink" title="五、Hexo基本操作"></a>五、Hexo基本操作</h3><p>博客文章都放在<code>source\_post</code>目录下</p>
]]></content>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS结构及源码解析.md</title>
    <url>/2020/03/31/AQS%E7%BB%93%E6%9E%84%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="AQS（AbstaractQueuedSynchronize）"><a href="#AQS（AbstaractQueuedSynchronize）" class="headerlink" title="AQS（AbstaractQueuedSynchronize）"></a>AQS（AbstaractQueuedSynchronize）</h2><blockquote>
<p>AQS支持两种方式: 1,独占式 2.共享式</p>
</blockquote>
<pre><code class="java">//AQS定义的以下可重写的方法：

1. protected boolean tryAcquire(int arg) 
//独占式获取同步状态，试着获取，成功返回true，反之为false

2. protected boolean tryRelease(int arg) 
//独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；

3. protected int tryAcquireShared(int arg) 
//共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；

4. protected boolean tryReleaseShared(int arg) 
//共享式释放同步状态，成功为true，失败为false

5. protected boolean isHeldExclusively()
//是否在独占模式下被线程占用。
</code></pre>
<h3 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h3><pre><code class="java">public class MyExclusiveLock {

    private final static int LOCK_HOLD_STATE = 1;

    private final static int LOCK_RELEASE_STATE = 0;

    private final Sync sync = new Sync();

    /**
     * 如果当前锁为0(释放状态)，则加锁
     */
    public void lock() {
        sync.acquire(LOCK_HOLD_STATE);
    }

    /**
     * 如果当前锁状态为1(独占)，则设置为0(释放),否则报错
     */
    public void unLock() {
        sync.release(LOCK_HOLD_STATE);
    }

    public boolean isLocked() {
        return sync.isHeldExclusively();
    }

    private static class Sync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            //首先判断状态是否等于=0,如果状态==0，就将status设置为1
            if (compareAndSetState(LOCK_RELEASE_STATE, LOCK_HOLD_STATE)) {
                //将当前线程赋值给独占模式的owner
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            if (getState() == LOCK_RELEASE_STATE) {
                throw new IllegalMonitorStateException();
            }
            setExclusiveOwnerThread(null);
            setState(LOCK_RELEASE_STATE);
            return true;
        }


        @Override
        protected boolean isHeldExclusively() {
            return getState() == LOCK_HOLD_STATE;
        }
    }


    private static CyclicBarrier barrier = new CyclicBarrier(31);

    private static int count;

    private static final MyExclusiveLock myLock = new MyExclusiveLock();

    public static void main(String[] args) throws Exception {
        for (int i = 0; i &lt; 30; i++) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 10000; j++) {
                    incrementUnSync();
                }
                try {
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
        barrier.await();
        System.out.println(&quot;没有加锁，count=&quot; + count);

        //加锁后
        barrier.reset();
        count = 0;
        for (int i = 0; i &lt; 30; i++) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 10000; j++) {
                    incrementUseLock();
                }
                try {
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
        barrier.await();
        System.out.println(&quot;加锁后，count=&quot; + count);
    }

    /**
     * 不使用同步机制自增
     */
    public static void incrementUnSync() {
        count++;
    }

    /**
     * 使用我们实现的锁
     */
    public static void incrementUseLock() {
        myLock.lock();
        count++;
        myLock.unLock();
    }
}
</code></pre>
<h3 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h3><blockquote>
<p>AQS的实现依赖内部的同步队列（FIFO双向队列），如果当前线程获取同步状态失败，AQS会将该线程以及等待状态等信息构造成一个Node，将其加入同步队列的尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点。</p>
</blockquote>
<p><img src="../image/AQS1.png" alt="AQS1"></p>
<h4 id="获取同步状态"><a href="#获取同步状态" class="headerlink" title="获取同步状态"></a>获取同步状态</h4><blockquote>
<p>假设线程A要获取同步状态（这里想象成锁，方便理解），初始状态下state=0,所以线程A可以顺利获取锁，A获取锁后将state置为1。在A没有释放锁期间，线程B也来获取锁，此时因为state=1，表示锁被占用，所以将B的线程信息和等待状态等信息构成出一个Node节点对象，放入同步队列，head和tail分别指向队列的头部和尾部（此时队列中有一个空的Node节点作为头点，head指向这个空节点，空Node的后继节点是B对应的Node节点，tail指向它），同时阻塞线程B(这里的阻塞使用的是LockSupport.park()方法)。后续如果再有线程要获取锁，都会加入队列尾部并阻塞。</p>
</blockquote>
<h4 id="释放同步状态"><a href="#释放同步状态" class="headerlink" title="释放同步状态"></a>释放同步状态</h4><blockquote>
<p>当线程A释放锁时，即将state置为0，此时A会唤醒头节点的后继节点（所谓唤醒，其实是调用LockSupport.unpark(B)方法），即B线程从LockSupport.park()方法返回，此时B发现state已经为0，所以B线程可以顺利获取锁，B获取锁后B的Node节点随之出队。</p>
</blockquote>
<h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><blockquote>
<p>Node结点是AbstractQueuedSynchronizer中的一个静态内部类.</p>
</blockquote>
<pre><code class="java">static final class Node {
    /** waitStatus值，表示线程已被取消（等待超时或者被中断）*/
    static final int CANCELLED = 1;
    /** waitStatus值，表示线程需要被唤醒（unpaking）*/
    static final int SIGNAL = -1;
    //waitStatus值，表示结点线程等待在condition上，当被signal后，会从等待队列转移到同步队列中/
    static final int CONDITION = -2;
    /** waitStatus值，表示下一次共享式同步状态会被无条件地传播下去**/
    static final int PROPAGATE = -3;
     /** 等待状态，初始为0 */
    volatile int waitStatus;
    /**当前结点的前驱结点 */
    volatile Node prev;
    /** 当前结点的后继结点 */
    volatile Node next;
    /** 与当前结点关联的排队中的线程 */
    volatile Thread thread;
}</code></pre>
<h4 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h4><p>ConditionObject实现接口Condition，先看看属性</p>
<pre><code class="java">//等待队列中的首节点
private transient Node firstWaiter;
//等待队列中的尾节点
private transient Node lastWaiter;</code></pre>
<h5 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h5><pre><code class="java">//返回当前线程（状态设置好的）
private Node addConditionWaiter() {
    //获取等待队列中的尾节点
    Node t = lastWaiter;
    //尾节点失效的情况
    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
        //从头节点开始剔除节点
        unlinkCancelledWaiters();
        t = lastWaiter;
    }
    //将当前线程的状态设为Condition
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}</code></pre>
<h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><pre><code class="java">public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
     //将当前线程封装成Node加入到等待队列尾部
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    //如果当前线程不在同步队列上，就将其阻塞
    //其他线程如果发出了signal信号之后，会把等待队列的线程移入同步队列，此时就会退出循环，进入下面的重新获取锁的acquireQueued
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    //其他发出signal信号的线程释放锁之后，该线程被唤醒并重新竞争锁
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}</code></pre>
<h5 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h5><pre><code class="java">final boolean isOnSyncQueue(Node node) {
        if (node.waitStatus == Node.CONDITION || node.prev == null)
            return false;
        //如果有后继节点，且不为head节点说明在同步队列中
        if (node.next != null) // If has successor, it must be on queue
            return true;
        return findNodeFromTail(node);
    }</code></pre>
<pre><code class="java">private boolean findNodeFromTail(Node node) {
    //获取等待队列尾节点
    Node t = tail;
    for (;;) {
        //从尾节点向前遍历
        if (t == node)
            return true;
        if (t == null)
            return false;
        t = t.prev;
    }
}</code></pre>
<h5 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal"></a>doSignal</h5><pre><code class="java">do { //从等待队列的头节点的后继节点向后继节点进行遍历，如果该节点为null，则将尾节点置为null
    //否则，将该节点的后继节点置为null
    if ( (firstWaiter = first.nextWaiter) == null)
        lastWaiter = null;
    first.nextWaiter = null;
} while (!transferForSignal(first) &amp;&amp;
         (first = firstWaiter) != null);</code></pre>
<h5 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h5><pre><code class="java">private void unlinkCancelledWaiters() {
    //获取等待队列中的头结点
    Node t = firstWaiter;
    Node trail = null;
     //头节点不为空时，从头节点开始向后剔除节点
    while (t != null) {
        Node next = t.nextWaiter;
        if (t.waitStatus != Node.CONDITION) {
            t.nextWaiter = null;
            if (trail == null)
                firstWaiter = next;
            else
                trail.nextWaiter = next;
            if (next == null)
                lastWaiter = trail;
        }
        else
            trail = t;
        t = next;
    }
}</code></pre>
<h4 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h4><p><strong>调用lock()方法时一般会直接代理到acquire方法</strong></p>
<pre><code class="java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

//等同于
public final void acquire(int arg) {
    //1.尝试获取锁，获取到直接结束。否则执行2
    boolean hasAcquired = tryAcquire(arg);
    //2.将当前线程构建成一个独占的Node节点
    Node currentThreadNode = addWaiter(Node.EXCLUSIVE);
    //3.尝试获取当前线程的同步状态，如果获取不到则阻塞队列，直到被前驱或者后继节点唤醒
    boolean interrupted = acquireQueued(currentThreadNode, arg);
    if (interrupted) {
       selfInterrupt(); 
    }
}</code></pre>
<h5 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h5><p><strong>再来看看addWaiter的实现</strong></p>
<pre><code class="java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    //尾节点不为null时，AQS操作将node放入队尾
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    //尾节点为null时直接入队
    enq(node);
    return node;
}

//再来看看入队方法
private Node enq(final Node node) {
    //死循环（无锁，利用cas防止创建多个同步队列）
    for (;;) {
        //尾节点为null时初始化（延迟加载，好腻害）
        Node t = tail;
        if (t == null) { // Must initialize
            //cas操作创建头节点
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            //cas操作放入队尾
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>
<h5 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h5><pre><code class="java"> final boolean acquireQueued(final Node node, int arg) {
     boolean failed = true;
     try {
         boolean interrupted = false;
         //死循环
         for (;;) {
             //找到当前结点的前驱结点
             final Node p = node.predecessor();
             //如果前驱结点是头结点，才tryAcquire，其他结点是没有机会tryAcquire的。
             if (p == head &amp;&amp; tryAcquire(arg)) {
                 //获取同步状态成功，将当前结点设置为头结点。
                 setHead(node);
                 //方便GC
                 p.next = null; 
                 failed = false;
                 return interrupted;
             }
             // 如果没有获取到同步状态，通过shouldParkAfterFailedAcquire判断是否应该阻塞，parkAndCheckInterrupt用来阻塞线程
             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                 parkAndCheckInterrupt())
                 interrupted = true;
         }
     } finally {
         if (failed)
             cancelAcquire(node);
     }
 }</code></pre>
<blockquote>
<p>可以看到，acquireQueued方法也是一个死循环，直到进入 if (p == head &amp;&amp; tryAcquire(arg))条件方法块。还是接着刚才的操作来分析。acquireQueued接收的参数是addWaiter方法的返回值。node.predecessor()返回当前节点的前置节点，在这里也就是head节点，所以p==head成立，进而进行tryAcquire操作，即争用锁, 如果获取成功，则进入if方法体，看下接下来的操作：</p>
<p>1) 将当前节点设置为头节点。<br>2) 将当前节点的前置节点设置的next设置为null。</p>
<p>上面操作即完成了FIFO的出队操作。<br>从上面的分析可以看出，只有队列的第二个节点可以有机会争用锁，如果成功获取锁，则此节点晋升为头节点。对于第三个及以后的节点，if (p == head)条件不成立，首先进行shouldParkAfterFailedAcquire(p, node)操作（争用锁失败的第二个节点也如此.</p>
</blockquote>
<h5 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h5><p><code>shouldParkAfterFailedAcquire方法是判断一个争用锁的线程是否应该被阻塞</code></p>
<pre><code class="java">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        //获取前驱节点的等待状态
        int ws = pred.waitStatus;
        //如果后继节点需要被唤醒
        if (ws == Node.SIGNAL)
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
            return true;                                                                       if (ws &gt; 0) {
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
                //只有CANCEL状态ws才大于0。若前驱结点处于CANCEL状态，也就是此结点线程已经无效，从后往前遍历，找到一个非CANCEL状态的结点，将自己设置为它的后继结点
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don&#39;t park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            // 若前驱结点为其他状态，将其设置为SIGNAL状态
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }</code></pre>
<blockquote>
<p>shouldParkAfterFailedAcquire方法是判断一个争用锁的线程是否应该被阻塞。它首先判断一个节点的前置节点的状态是否为Node.SIGNAL，如果是，是说明此节点已经将状态设置，如果锁释放，则应当通知它，所以它可以安全的阻塞了，返回true。</p>
<p>如果前节点的状态大于0，即为CANCELLED状态时，则会从前节点开始逐步循环找到一个没有被“CANCELLED”节点设置为当前节点的前节点，返回false。在下次循环执行shouldParkAfterFailedAcquire时，返回true。这个操作实际是把队列中CANCELLED的节点剔除掉。</p>
<p>如果shouldParkAfterFailedAcquire返回了true，则会执行：“parkAndCheckInterrupt()”方法，它是通过LockSupport.park(this)将当前线程挂起到WATING状态，它需要等待一个中断、unpark方法来唤醒它，通过这样一种FIFO的机制的等待，来实现了Lock的操作。</p>
</blockquote>
<pre><code class="java">    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }</code></pre>
<h5 id="release"><a href="#release" class="headerlink" title="release"></a>release</h5><p><strong>当前线程执行完自己的逻辑之后，需要释放同步状态，来看看release方法的逻辑:</strong></p>
<pre><code class="java">public final boolean release(int arg) {
    //调用使用者重写的tryRelease方法，若成功，唤醒其后继结点，失败则返回false
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            //唤醒后继结点
            unparkSuccessor(h);
        return true;
    }
    return false;
}</code></pre>
<p><strong>在方法unparkSuccessor(Node)中，就意味着真正要释放锁了，它传入的是head节点（head节点是占用锁的节点），看下源码：</strong></p>
<pre><code class="java">private void unparkSuccessor(Node node) {
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        int ws = node.waitStatus;
        if (ws &lt; 0)
            // 将等待状态waitStatus设置为初始值0
            compareAndSetWaitStatus(node, ws, 0);

        /*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         */
        Node s = node.next;
    //若后继结点为空，或状态为CANCEL（已失效），则从后尾部往前遍历找到一个处于正常阻塞状态的结点进行唤醒
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        }
        if (s != null)
            //使用LockSupprot唤醒结点对应的线程
            LockSupport.unpark(s.thread);
    }</code></pre>
<p><strong>内部首先会发生的动作是获取head节点的next节点，如果获取到的节点不为空，则直接通过：“LockSupport.unpark()”方法来释放对应的被挂起的线程，这样一来将会有一个节点唤醒后继续进入循环进一步尝试tryAcquire()方法来获取锁。</strong></p>
<h4 id="共享式源码简单分析"><a href="#共享式源码简单分析" class="headerlink" title="共享式源码简单分析"></a>共享式源码简单分析</h4><blockquote>
<p>共享式：共享式地获取同步状态。对于独占式同步组件来讲，同一时刻只有一个线程能获取到同步状态，其他线程都得去排队等待，其待重写的尝试获取同步状态的方法tryAcquire返回值为boolean，这很容易理解；对于共享式同步组件来讲，同一时刻可以有多个线程同时获取到同步状态，这也是“共享”的意义所在。其待重写的尝试获取同步状态的方法tryAcquireShared返回值为int。</p>
</blockquote>
<pre><code class="java">protected int tryAcquireShared(int arg) {
    throw new UnsupportedOperationException();
}</code></pre>
<p>​    <strong>1.当返回值大于0时，表示获取同步状态成功，同时还有剩余同步状态可供其他线程获取；</strong></p>
<p>　　<strong>2.当返回值等于0时，表示获取同步状态成功，但没有可用同步状态了；</strong></p>
<p>　　<strong>3.当返回值小于0时，表示获取同步状态失败。</strong></p>
<h5 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared　"></a>acquireShared　</h5><pre><code class="java">public final void acquireShared(int arg) {
    //返回值小于0，获取同步状态失败，排队去；获取同步状态成功，直接返回去干自己的事儿。
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}</code></pre>
<h5 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h5><pre><code class="java">private void doAcquireShared(int arg) {
    //构造一个共享结点，添加到同步队列尾部。若队列初始为空，先添加一个无意义的傀儡结点，再将新节点添加到队列尾部。
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        //线程parking过程中是否被中断过
        boolean interrupted = false;
        for (;;) {
            //获取前驱
            final Node p = node.predecessor();
            //头结点持有同步状态，只有前驱是头结点，才有机会尝试获取同步状态
            if (p == head) {
                //尝试获取同步状态
                int r = tryAcquireShared(arg);
                if (r &gt;= 0) {
                    //获取成功就将当前结点设置为头结点，若还有可用资源，传播下去，也就是继续唤醒后继结
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            // 如果没有获取到同步状态，通过shouldParkAfterFailedAcquire判断是否应该阻塞，parkAndCheckInterrupt用来阻塞线程
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}</code></pre>
<p><strong>大体逻辑与独占式的acquireQueued差距不大，只不过由于是共享式，会有多个线程同时获取到线程，也可能同时释放线程，空出很多同步状态，所以当排队中的老二获取到同步状态，如果还有可用资源，会继续传播下去。</strong></p>
<pre><code class="java">private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node);
    //propagate&gt;0即同步状态成功，且可供后续获取,waitStatus&lt;0即之前的头节点被终止
    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
        (h = head) == null || h.waitStatus &lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}</code></pre>
<h5 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h5><pre><code class="java">private void doReleaseShared() {
        for (;;) {
            //死循环，共享模式，持有同步状态的线程可能有多个，采用循环CAS保证线程安全
            Node h = head;
            if (h != null &amp;&amp; h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    //唤醒后继结点
                    unparkSuccessor(h);
                }
                else if (ws == 0 &amp;&amp;
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
    }</code></pre>
<p><strong>代码逻辑比较容易理解，需要注意的是，共享模式，释放同步状态也是多线程的，此处采用了CAS自旋来保证。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong><font style="color:red">AQS是JUC中很多同步组件的构建基础，简单来讲，它内部实现主要是状态变量state和一个FIFO队列来完成，同步队列的头结点是当前获取到同步状态的结点，获取同步状态state失败的线程，会被构造成一个结点（或共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会阻塞；释放时唤醒头结点的后继结点，使其加入对同步状态的争夺中。</font></strong></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发包</tag>
      </tags>
  </entry>
</search>
