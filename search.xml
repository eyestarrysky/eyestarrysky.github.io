<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hasor DataWay 简化后台开发</title>
    <url>/2020/05/01/Hasor%20DataWay%20%E7%AE%80%E5%8C%96%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>五一小长假终于来了，在放假之前我就做好打算，在家宅着与代码为伴，学一些自己感兴趣的东西。偶然看见一个介绍Hasor Dataway的文章，能够简化后端繁琐的开发，抛弃controller，service，mapper，dao等繁琐的工作，直接将数据更直接的展示出来。所以我也就只是介绍快速搭建一个开发环境，以及一些基本的使用，不求甚解，只是纯粹出于个人的兴趣，以后有时间说不定再研究一下。</p>
</blockquote>
<p><code>Dataway文档地址</code>：<a href="https://www.hasor.net/web/index.html" target="_blank" rel="noopener">https://www.hasor.net/web/index.html</a></p>
<p><code>Hasor的仓库地址</code>:    <a href="https://gitee.com/zycgit/hasor.git" target="_blank" rel="noopener">https://gitee.com/zycgit/hasor.git</a></p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- 引入依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.hasor&lt;/groupId&gt;
    &lt;artifactId&gt;hasor-spring&lt;/artifactId&gt;
    &lt;version&gt;4.1.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.hasor&lt;/groupId&gt;
    &lt;artifactId&gt;hasor-dataway&lt;/artifactId&gt;
    &lt;version&gt;4.1.4&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><pre><code class="yaml"># 配置我的连接的通用属性
alicloud:
  host: xxx
  username: xxx
  password: xxx

spring:
  datasource:
    #    最好用的数据源，速度最快 HikariCP
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://${alicloud.host}:3306/community
    username: ${alicloud.username}
    password: ${alicloud.password}

# 启用 Dataway 功能（默认不启用）
HASOR_DATAQL_DATAWAY: true
  # 开启 ui 管理功能（注意生产环境必须要设置为 false，否则会造成严重的生产安全事故）
HASOR_DATAQL_DATAWAY_ADMIN: true
  # （可选）API工作路径
HASOR_DATAQL_DATAWAY_API_URL: /api/
  # （可选）ui 的工作路径，只有开启 ui 管理功能后才有效
HASOR_DATAQL_DATAWAY_UI_URL: /interface-ui/</code></pre>
<h4 id="初始化sql"><a href="#初始化sql" class="headerlink" title="初始化sql"></a>初始化sql</h4><ul>
<li><code>sql</code>在<code>hasor-dataway</code>的<code>META-INF/hasor-framework</code>下可以找到</li>
</ul>
<pre><code class="mysql">CREATE TABLE `interface_info` (
    `api_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;ID&#39;,
    `api_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,
    `api_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,
    `api_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0草稿，1发布，2有变更，3禁用&#39;,
    `api_comment`     varchar(255)     NULL                  COMMENT &#39;注释&#39;,
    `api_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,
    `api_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,
    `api_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,
    `api_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,
    `api_create_time` datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
    `api_gmt_time`    datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
    PRIMARY KEY (`api_id`)
) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway 中的API&#39;;


CREATE TABLE `interface_release` (
    `pub_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;Publish ID&#39;,
    `pub_api_id`      int(11)      NOT NULL                  COMMENT &#39;所属API ID&#39;,
    `pub_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,
    `pub_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,
    `pub_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0有效，1无效（可能被下线）&#39;,
    `pub_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,
    `pub_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,
    `pub_script_ori`  mediumtext   NOT NULL                  COMMENT &#39;原始查询脚本，仅当类型为SQL时不同&#39;,
    `pub_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,
    `pub_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,
    `pub_release_time`datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;发布时间（下线不更新）&#39;,
    PRIMARY KEY (`pub_id`)
) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway API 发布历史。&#39;;

create index idx_interface_release on interface_release (pub_api_id);</code></pre>
<h4 id="将Datasource注入Hasor容器"><a href="#将Datasource注入Hasor容器" class="headerlink" title="将Datasource注入Hasor容器"></a>将Datasource注入Hasor容器</h4><ul>
<li>在项目目录下建一个<code>hasor目录</code></li>
</ul>
<pre><code class="java">package xxx.hasor;

import net.hasor.core.ApiBinder;
import net.hasor.core.DimModule;
import net.hasor.db.JdbcModule;
import net.hasor.db.Level;
import net.hasor.spring.SpringModule;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import javax.sql.DataSource;

/**
 * @author : eyestarrysky
 * @date : Created in 2020/5/1
 */
@DimModule
@Component
public class HasorModule implements SpringModule {

    @Resource
    private DataSource dataSource;

    @Override
    public void loadModule(ApiBinder apiBinder) throws Throwable {
        apiBinder.installModule(new JdbcModule(Level.Full, this.dataSource));
    }
}
</code></pre>
<h4 id="SpringBoot启动类开启Hasor注解"><a href="#SpringBoot启动类开启Hasor注解" class="headerlink" title="SpringBoot启动类开启Hasor注解"></a>SpringBoot启动类开启Hasor注解</h4><pre><code class="java">package xxx;

import net.hasor.spring.boot.EnableHasor;
import net.hasor.spring.boot.EnableHasorWeb;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@EnableHasor
@EnableHasorWeb
@SpringBootApplication
public class DatawayApplication {

    public static void main(String[] args) {
        SpringApplication.run(DatawayApplication.class, args);
    }

}</code></pre>
<h4 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h4><pre><code class="verilog"> _    _                        ____              _
| |  | |                      |  _ \            | |
| |__| | __ _ ___  ___  _ __  | |_) | ___   ___ | |_
|  __  |/ _` / __|/ _ \| &#39;__| |  _ &lt; / _ \ / _ \| __|
| |  | | (_| \__ \ (_) | |    | |_) | (_) | (_) | |_
|_|  |_|\__,_|___/\___/|_|    |____/ \___/ \___/ \__|</code></pre>
<ul>
<li>项目启动成功，访问<code>http://localhost:8080/interface-ui/</code>即可</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li>接口面板</li>
</ul>
<p><img src="http://qiniu.eyestarrysky.top/dataway-console.png" alt="找不到"></p>
<ul>
<li>新增接口，右边几个按钮分别为<code>save</code>，<code>execute</code>, <code>test</code>, <code>publish</code></li>
</ul>
<p><img src="http://qiniu.eyestarrysky.top/dataway-new-interface.png" alt="找不到"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>DataQL</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jetcache来操作缓存</title>
    <url>/2020/04/27/%E4%BD%BF%E7%94%A8jetcache%E6%9D%A5%E6%93%8D%E4%BD%9C%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="Jetcache前言"><a href="#Jetcache前言" class="headerlink" title="Jetcache前言"></a>Jetcache前言</h3><ul>
<li><code>git</code>地址:  <a href="https://github.com/alibaba/jetcache/" target="_blank" rel="noopener">https://github.com/alibaba/jetcache/</a></li>
</ul>
<p>​        <strong>因为之前项目的原因接触过jecache，但是没有好好整理，今天闲下来，悉心整理了下，并看了下文档，学了下自动刷新缓存，感觉这个挺适合用来更新首页轮播图，通栏的。</strong></p>
<h3 id="基本配置（Spring-Boot"><a href="#基本配置（Spring-Boot" class="headerlink" title="基本配置（Spring Boot)"></a>基本配置（Spring Boot)</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><pre><code class="xml">&lt;!-- jetCache  --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;
    &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;
    &lt;version&gt;2.6.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><pre><code class="yml">#jetcache
# @see com.alicp.jetcache.autoconfigure.JetCacheProperties
jetcache:
  # 统计间隔，默认0：表示不统计
  statIntervalMinutes: 1
  # areaName是否作为缓存key前缀，默认True
  areaInCacheName: false
  local:
    default:
      # 已支持可选：linkedhashmap、caffeine
      type: linkedhashmap
      # key转换器的全局配置，当前只有：fastjson, @see com.alicp.jetcache.support.FastjsonKeyConvertor
      keyConvertor: fastjson
      # 每个缓存实例的最大元素的全局配置，仅local类型的缓存需要指定
      limit: 100
      # jetcache2.2以上，以毫秒为单位，指定多长时间没有访问，就让缓存失效，当前只有本地缓存支持。0表示不使用这个功能，指定30秒后失效
      expireAfterAccessInMillis: 30000
  remote:
    default:
      type: redis
      keyConvertor: fastjson
      valueEncoder: java
      valueDecoder: java
      poolConfig:
        minIdle: 5
        maxIdle: 20
        maxTotal: 50
      host: ${redis.host}
      port: 6379
      password: ${redis.password}</code></pre>
<h5 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h5><pre><code class="java">@SpringBootApplication
@EnableMethodCache(basePackages = &quot;com.company.mypackagee&quot;)
@EnableCreateCacheAnnotation
public class Application extends SpringBootServletInitializer {

    public static void main(String[] args) {
        SpringApplication.run(Application.class);
    }
}</code></pre>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li><p>下面例子以操作<code>User</code>为例<br><code>user.java</code></p>
<pre><code class="java">@TableName(value = &quot;user&quot;)
@Data
public class User implements Serializable {
    private static final long serialVersionUID = 738881519595997996L;
    /**主键**/
    @NotNull(message = &quot;主键不能为空&quot;)
    private Long id;
    /**姓名**/
    @NotBlank(message = &quot;名字不能为空&quot;)
    @Length(min = 1, message = &quot;名字至少1个字&quot;)
    private String name;
    /**手机号**/
    @NotBlank(message = &quot;手机号不能为空&quot;)
    @Size(max = 11, message = &quot;手机号最长11位&quot;)
    @Pattern(regexp = &quot;^1\\d+$&quot;, message = &quot;手机号格式不正确&quot;)
    private String phone;
    /**电子邮件**/
    @NotBlank(message = &quot;邮箱不能为空&quot;)
    @Email(message = &quot;电子邮件格式不正确&quot;)
    @Length(max = 30, message = &quot;邮箱长度不能超过30!&quot;)
    private String email;
    /**自我介绍**/
    private String aboutme;
    /**加密密码**/
    private String passwd;
    /**头像图片**/
    private String avatar;
    /**1:普通用户，2:房产经纪人**/
    private Integer type;
    /**创建时间**/
    private Date createTime;
    /**是否启用,1启用，0停用**/
    private Integer enable;
    /**所属经纪机构**/
    private Integer agencyId;
}</code></pre>
</li>
</ul>
<h4 id="基于注解实现方法缓存"><a href="#基于注解实现方法缓存" class="headerlink" title="基于注解实现方法缓存"></a>基于注解实现方法缓存</h4><h5 id="Cached：创建缓存"><a href="#Cached：创建缓存" class="headerlink" title="@Cached：创建缓存"></a>@Cached：创建缓存</h5><pre><code class="java">/**
 * 基于注解创建缓存
 * 缓存在 Remote 的 Redis，也可以配置成 both 开启两级缓存
 */
@Cached(name = CACHE_NAME, key = &quot;#userId&quot;, cacheType = CacheType.LOCAL, expire = 5 * 60)
public UserVO findUserById(Long userId) {
    User user = userMapper.selectOne(queryWrapper);
    //.....................
}</code></pre>
<h5 id="CacheInvalidate：删除缓存"><a href="#CacheInvalidate：删除缓存" class="headerlink" title="@CacheInvalidate：删除缓存"></a>@CacheInvalidate：删除缓存</h5><pre><code class="java">@CacheInvalidate(name = CACHE_NAME, key = &quot;#userId&quot;)
@Transactional(rollbackFor = Exception.class)
public int deleteUserById(Long userId) {
    User user = new User();
    user.setId(userId);
    user.setEnable(0);
    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();
    updateWrapper.lambda().eq(User::getId, userId).eq(User::getEnable, 1);
    return userMapper.update(user, updateWrapper);
}</code></pre>
<h4 id="基于-CreateCache注解创建Cache实例"><a href="#基于-CreateCache注解创建Cache实例" class="headerlink" title="基于@CreateCache注解创建Cache实例"></a>基于@CreateCache注解创建Cache实例</h4><h5 id="CreateCache"><a href="#CreateCache" class="headerlink" title="@CreateCache"></a>@CreateCache</h5><pre><code class="java">/**
 * 使用 @CreateCache 注解创建Cache实例;
 * 未定义默认值的参数，将使用yml中指定的全局配置;
 * 缓存在 Local，也可以配置成 both 开启两级缓存
 */
@CreateCache(name = CACHE_NAME, expire = 5 * 60, localLimit = 10, cacheType = CacheType.LOCAL)
private Cache&lt;Long, UserVO&gt; userCache;</code></pre>
<h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><pre><code class="java">public UserVO getUserByIdAndCreateCache(Long userId) {
    //根据id从缓存中取
    UserVO userVO = userCache.get(userId);
    log.info(&quot;userCreateCache get {} res {}&quot;, userId, userCache);
    if (Objects.isNull(userVO)) {
        User user = userMapper.selectById(userId);
        if (Objects.nonNull(user)) {
            userVO = new UserVO();
            BeanUtils.copyProperties(user, userVO);
            //如果不存在就放入缓存中
            boolean res = userCache.putIfAbsent(user.getId(), userVO);
            log.info(&quot;userCreateCache putIfAbsent {} res {}&quot;, userId, res);
        }
    }
    return userVO;
}</code></pre>
<h5 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h5><pre><code class="java">@Transactional(rollbackFor = Exception.class)
public int deleteUserByIdAndCreateCache(Long userId) {
    User user = new User();
    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();
    updateWrapper.lambda().eq(User::getId, userId).eq(User::getEnable, 1);
    user.setId(userId);
    user.setEnable(0);
    int result = userMapper.update(user, updateWrapper);
    if (result &gt; 0) {
        //根据key = userId删除缓存
        boolean deleteResult = userCache.remove(userId);
        log.info(&quot;同步删除缓存, userId = {}, res = {}&quot;, userId, deleteResult);
    }
    return result;
}</code></pre>
<h3 id="高级API"><a href="#高级API" class="headerlink" title="高级API"></a>高级API</h3><h4 id="自动刷新缓存"><a href="#自动刷新缓存" class="headerlink" title="自动刷新缓存"></a>自动刷新缓存</h4><blockquote>
<p>从JetCache2.2版本开始，RefreshCache基于decorator模式提供了自动刷新的缓存的能力，目的是为了防止缓存失效时造成的雪崩效应打爆数据库。 对一些key比较少，实时性要求不高，加载开销非常大的缓存场景，适合使用自动刷新。上面的代码指定每分钟刷新一次，30分钟如果没有访问就停止刷新。如果缓存是redis或者多级缓存最后一级是redis，缓存加载行为是全局唯一的，也就是说不管有多少台服务器，同时只有一个服务器在刷新，这是通过tryLock实现的，目的是为了降低后端的加载负担。 </p>
</blockquote>
<pre><code class="java">@CreateCache(name = CACHE_NAME, expire = 5 * 60, localLimit = 10, cacheType = CacheType.LOCAL)
private Cache&lt;Long, UserVO&gt; userCache;

@PostConstruct
public void init() {
    //设置每分钟自动刷新，30分钟不访问就停止自动刷新
    RefreshPolicy refreshPolicy = RefreshPolicy.newPolicy(1,                    TimeUnit.MINUTES).stopRefreshAfterLastAccess(30,                                     TimeUnit.MINUTES);
    //放入需要装载自动刷新的方法getUserByIdAndCreateCache()
    userCache.config().setLoader(this::getUserByIdAndCreateCache);
    userCache.config().setRefreshPolicy(refreshPolicy);
}</code></pre>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>jetcache</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>利用github和hexo快速搭建个人博客</title>
    <url>/2020/04/17/%E5%88%A9%E7%94%A8github%E5%92%8Chexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p><code>git</code>下载地址：<code>http://gitforwindows.org</code></p>
<h4 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><p> <code>node.js</code> 下载地址：<code>http://nodejs.org/en/</code> </p>
<h3 id="二、本地搭建"><a href="#二、本地搭建" class="headerlink" title="二、本地搭建"></a>二、本地搭建</h3><ul>
<li><p>选择一个文件夹建一个目录<code>blog</code>存放博客相关文件，文件夹内右键打开<code>git bash here</code>，在窗口中执行以下所有命令</p>
</li>
<li><p>用<code>npm</code>安装<code>hexo</code>，由于国内网络高“墙”深院，避免安装缓慢或失败，这里切换阿里的<code>NPM</code>镜像，没办法只能采用迂回战术了。</p>
</li>
</ul>
<pre><code class="sh">$ npm install -g cnpm --registry=http://registry.npm.taobao.org</code></pre>
<p>用 <code>cnpm</code> 安装 <code>hexo</code></p>
<pre><code class="sh">$ cnpm install -g hexo-cli
$ cnpm install hexo --save
##检查hexo是否安装成功
$ hexo -v</code></pre>
<ul>
<li>在<code>blog</code>文件夹建一个<code>hexo</code>文件存放博客，进入也打开<code>git bash here</code></li>
</ul>
<pre><code class="sh">$ hexo init</code></pre>
<p>初始化成功后，<code>hexo文件</code>夹内会出现如下的文件：</p>
<p><code>node_modules</code>: 依赖包<br><code>public</code>：存放生成的页面<br><code>scaffolds</code>：生成文章的一些模板<br><code>source</code>：用来存放你的文章<br><code>themes</code>：放下下载的主题<br><code>_config.yml:</code> 博客的核心配置文件（设置主体、标题等属性）</p>
<ul>
<li><p>接着需要执行一下<code>cnpm install</code>命令，要不下边的启动会提示命令不合法。</p>
</li>
<li><p>最后使用<code>hexo s -g</code>启动安装好的<code>hexo</code></p>
</li>
</ul>
<h3 id="三、托管至GitHub"><a href="#三、托管至GitHub" class="headerlink" title="三、托管至GitHub"></a>三、托管至GitHub</h3><ul>
<li><p>建立一个仓库，名称为<code>xxx.github.io</code></p>
</li>
<li><p>配置<code>_config.xml</code>文件，添加<code>GitHub</code>地址</p>
</li>
</ul>
<pre><code class="yml">deploy:
  type: git
  repo: https://github.com/xxx/xxx.github.io.git
  branch: master</code></pre>
<ul>
<li>安装部署命令<code>deploy-git</code> ，这样你才能用命令部署到<code>GitHub</code></li>
</ul>
<pre><code class="sh">$ cnpm install hexo-deployer-git  --save</code></pre>
<ul>
<li>安装好后，依次执行下列命令，提交本地<code>hexo</code>文件到<code>GitHub</code></li>
</ul>
<pre><code class="sh">$ hexo clean
$ hexo generate
$ hexo deploy</code></pre>
<ul>
<li>最后访问<code>https://xxx.github.io.git</code>即可</li>
</ul>
<h3 id="四、选择自己喜欢的主题"><a href="#四、选择自己喜欢的主题" class="headerlink" title="四、选择自己喜欢的主题"></a>四、选择自己喜欢的主题</h3><ul>
<li><p>到<code>http://hexo.io/themes/</code>下载主题，<code>git clone</code>到本地</p>
<p><code>git clone https://github.com/iissnan/hexo-theme-next</code></p>
</li>
<li><p>修改<code>hexo</code>文件夹下的<code>_config.yml</code>文件中的<code>theme</code>属性</p>
</li>
</ul>
<pre><code class="yml">theme: hexo-theme-next</code></pre>
<ul>
<li>再次打包上传即可<pre><code class="sh">$ hexo clean
$ hexo generate
$ hexo deploy</code></pre>
</li>
</ul>
<h3 id="五、Hexo基本操作"><a href="#五、Hexo基本操作" class="headerlink" title="五、Hexo基本操作"></a>五、Hexo基本操作</h3><p>博客文章都放在<code>source\_post</code>目录下</p>
]]></content>
      <categories>
        <category>hexo</category>
        <category>建站</category>
      </categories>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
</search>
