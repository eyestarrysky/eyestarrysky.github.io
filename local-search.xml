<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>温故知新-redis过期策略及应用</title>
    <link href="/2020/05/24/%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/24/%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>当人们在过五一长假时<code>Redis 6.0</code>悄然发布了，这个版本提供了许多新特性和一些功能上的改进，其中最引入关注的当属“多线程”了。但是，本文先不谈新特性，先对本人学过的<code>redis</code>相关知识及应用做一下回顾，以后抽空会再写一篇我对<code>Redis 6.0</code>的所知所学</li></ul><h3 id="Redis的过期策略是什么"><a href="#Redis的过期策略是什么" class="headerlink" title="Redis的过期策略是什么"></a>Redis的过期策略是什么</h3><h4 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h4><ul><li>解答是<code>定期删除</code> +  <code>惰性删除</code><ul><li><code>定期删除</code>指的是<code>redis</code>默认每隔<code>100ms</code>就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除</li><li>由于定期删除可能会导致key到过期时间了，没有被随机抽取删除掉，所以有了<code>惰性删除</code>，当使用获取key操作时，<code>redis</code>会检查key是否过期，如果过期了就删除掉不会返回任何东西</li></ul></li></ul><p><strong>但是如果某个key一直没有获取操作或者被定期删除随机抽取到，那么也会堆积大量key在内存里，所以有了内存淘汰机制</strong></p><h4 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h4><p><strong>redis 内存淘汰机制有以下几个：</strong></p><ul><li><code>noeviction</code>: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</li><li><code>allkeys-lru</code>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li><li><code>allkeys-random</code>：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</li><li><code>volatile-lru</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。</li><li><code>volatile-random</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。</li><li><code>volatile-ttl</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。</li></ul><h3 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h3><blockquote><p>我在公司负责过一个直播项目，主播会提前预约一个直播间，然后把直播间通过社交软件分享出去吸引流量；如果预约时间过了10分钟还没有来开播，那么会删除直播间 + 七牛直播云关闭<code>Stream</code> + <code>imId</code>（当然，到了预约时间提前10分钟会push给主播提醒他开播，这些跟本文无关就不提了 )。</p></blockquote><h4 id="解决方案选择"><a href="#解决方案选择" class="headerlink" title="解决方案选择"></a>解决方案选择</h4><ol><li>使用<code>MQ</code>的延时消息来做，但是当时研究发现<code>RocketMQ</code>只支持指定的延时级别1s, 2s, … , 2h，没办法指定到具体的时间，其实这一点也能想到，RocketMQ作为一个高吞吐，低延时的消息队列，不设计这种具体到指定时间的延时消息也情有可原，因为这样就要在对消息排序上做大量处理，会极大地影响性能。于是 ，此方案不予采用。</li><li>采用定时任务来做，但是这样会很纠结这个定时任务的轮询时间，5分钟1次？2分钟1次？这样也没办法指定到具体时间，思来想去总觉得这个方案不太优雅，嗯，弃用。</li><li>自己实现一个时间轮？嗯，因为之前自己实现过一个时间轮，就拷贝到项目中使用，效果还不错，但是由于任务是放在内存中的，项目一重启，或者其他原因故障会导致任务丢失。这样一来那些空无一人的直播间挂在我们的直播首页也不太美观。于是考虑到要对任务做持久化，嗯，这样复杂度越来越高，而且还要新增业务表；于是乎，此方案也不采用。</li><li>最后是采用监听<code>redis</code> 的key过期事件来处理这个问题：将直播间<code>roomId:</code>做为key前缀，<code>expireTime</code> = 预约开播时间 + 10分钟 - 当前时间。当监听到指定key过期时，调用指定业务方法区处理。这样一来不需要引入额外的中间件，编码复杂度低，处理时间十分精确，完美地解决问题。</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><ul><li><strong><font style="color:red;">注意：需要开启<code>Redis</code> key 过期提醒，在<code>redis.conf</code>中加入<code>notify-keyspace-events Ex</code>配置 </font></strong></li></ul><h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><pre><code class="java">@Configurationpublic class RedisConfig {    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(factory);        // 设置key的序列化方式        template.setKeySerializer(RedisSerializer.string());        // 设置value的序列化方式        template.setValueSerializer(RedisSerializer.json());        // 设置hash的key的序列化方式        template.setHashKeySerializer(RedisSerializer.string());        // 设置hash的value的序列化方式        template.setHashValueSerializer(RedisSerializer.json());        template.afterPropertiesSet();        return template;    }    /**     * 将redis消息监听器注册为一个bean     * @param connectionFactory 链接工厂     * @return RedisMessageListenerContainer     */    @Bean    public RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory) {        RedisMessageListenerContainer container = new RedisMessageListenerContainer();        container.setConnectionFactory(connectionFactory);        return container;    }}</code></pre><h5 id="key过期监听类"><a href="#key过期监听类" class="headerlink" title="key过期监听类"></a>key过期监听类</h5><pre><code class="java">@Slf4j@Componentpublic class RedisKeyExpirationListener extends KeyExpirationEventMessageListener {    public RedisKeyExpirationListener(RedisMessageListenerContainer listenerContainer) {        super(listenerContainer);    }    @Override    public void onMessage(Message message, byte[] pattern) {        //获取失效的key, 进行对应的业务处理        String expiredKey = message.toString();        //取redis前缀符合的进行乡音处理        if (expiredKey.startsWith(RedisKeyConstant.LIVE_ROOM_CLOSE)) {            log.info(&quot;【这里进行对应的业务处理】, 业务key = {}过期&quot;, expiredKey);        }    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>​        其实，我这里的实战演练中的业务对时间点选择不是那么敏感，采用定时任务去处理，稍微晚那么几分钟关闭过期未及时开播的直播间也未尝不可，只是我个人是觉得监听redis key过期的方案更优雅，实现也简单罢了。其实这种方案适合很多种场景，比如订单30分钟超时未支付取消订单也非常适合使用。在未来我也会对自己所知所学多做总结，希望能做到温故知新，在日常学习中提升技术广度，在工作中践行技术深度，自我勉励！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode题解-102.二叉树的层序遍历</title>
    <link href="/2020/05/14/LeetCode%E9%A2%98%E8%A7%A3-102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/05/14/LeetCode%E9%A2%98%E8%A7%A3-102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><ul><li>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</li></ul><pre><code class="markdown">示例：二叉树：[3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7返回其层次遍历结果：[  [3],  [9,20],  [15,7]]</code></pre><h4 id="深度度优先遍历-DFS"><a href="#深度度优先遍历-DFS" class="headerlink" title="深度度优先遍历-DFS"></a>深度度优先遍历-DFS</h4><pre><code class="java">class Solution {    List&lt;List&lt;Integer&gt;&gt; depthList = new ArrayList&lt;&gt;();    /**     * 解法一: 采用深度优先遍历     * @param root 根节点     * @return List&lt;List&lt;Integer&gt;&gt;     */    public List&lt;List&lt;Integer&gt;&gt; levelOrderUseDFS(TreeNode root) {        if (null == root) {            return depthList;        }        recursive(root, 0);        return depthList;    }    public void recursive(TreeNode node, int depth) {        if (depthList.size() == depth) {            //这里使用链表，不需要扩容            depthList.add(new LinkedList&lt;&gt;());        }        depthList.get(depth).add(node.val);        if (null != node.left) {            recursive(node.left, depth + 1);        }        if (null != node.right) {            recursive(node.right, depth + 1);        }    }}</code></pre><h4 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历-BFS"></a>广度优先遍历-BFS</h4><pre><code class="java">     /**     * 解法二: 采用深度优先遍历     * @param root 根节点     * @return List&lt;List&lt;Integer&gt;&gt;     */    public List&lt;List&lt;Integer&gt;&gt; levelOrderUseBFS(TreeNode root) {        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        if (null == root) {            return res;        }        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            List&lt;Integer&gt; list = new LinkedList&lt;&gt;();            //内循环取出位于二叉树同一层的元素            for (int i = 0; i &lt; size; i++) {                TreeNode cur = queue.remove();                list.add(cur.val);                if (null != cur.left) {                    queue.add(cur.left);                }                if (null != cur.right) {                    queue.add(cur.right);                }            }            res.add(list);        }        return res;    }</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hasor DataWay 简化后台开发</title>
    <link href="/2020/05/01/Hasor%20DataWay%20%E7%AE%80%E5%8C%96%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    <url>/2020/05/01/Hasor%20DataWay%20%E7%AE%80%E5%8C%96%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>五一小长假终于来了，在放假之前我就做好打算，在家宅着与代码为伴，学一些自己感兴趣的东西。偶然看见一个介绍Hasor Dataway的文章，能够简化后端繁琐的开发，抛弃controller，service，mapper，dao等繁琐的工作，直接将数据更直接的展示出来。所以我也就只是介绍快速搭建一个开发环境，以及一些基本的使用，不求甚解，只是纯粹出于个人的兴趣，以后有时间说不定再研究一下。</p></blockquote><p><code>Dataway文档地址</code>：<a href="https://www.hasor.net/web/index.html" target="_blank" rel="noopener">https://www.hasor.net/web/index.html</a></p><p><code>Hasor的仓库地址</code>:    <a href="https://gitee.com/zycgit/hasor.git" target="_blank" rel="noopener">https://gitee.com/zycgit/hasor.git</a></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 引入依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-spring&lt;/artifactId&gt;    &lt;version&gt;4.1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-dataway&lt;/artifactId&gt;    &lt;version&gt;4.1.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><pre><code class="yaml"># 配置我的连接的通用属性alicloud:  host: xxx  username: xxx  password: xxxspring:  datasource:    #    最好用的数据源，速度最快 HikariCP    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://${alicloud.host}:3306/community    username: ${alicloud.username}    password: ${alicloud.password}# 启用 Dataway 功能（默认不启用）HASOR_DATAQL_DATAWAY: true  # 开启 ui 管理功能（注意生产环境必须要设置为 false，否则会造成严重的生产安全事故）HASOR_DATAQL_DATAWAY_ADMIN: true  # （可选）API工作路径HASOR_DATAQL_DATAWAY_API_URL: /api/  # （可选）ui 的工作路径，只有开启 ui 管理功能后才有效HASOR_DATAQL_DATAWAY_UI_URL: /interface-ui/</code></pre><h4 id="初始化sql"><a href="#初始化sql" class="headerlink" title="初始化sql"></a>初始化sql</h4><ul><li><code>sql</code>在<code>hasor-dataway</code>的<code>META-INF/hasor-framework</code>下可以找到</li></ul><pre><code class="mysql">CREATE TABLE `interface_info` (    `api_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;ID&#39;,    `api_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,    `api_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,    `api_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0草稿，1发布，2有变更，3禁用&#39;,    `api_comment`     varchar(255)     NULL                  COMMENT &#39;注释&#39;,    `api_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,    `api_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,    `api_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,    `api_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,    `api_create_time` datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,    `api_gmt_time`    datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,    PRIMARY KEY (`api_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway 中的API&#39;;CREATE TABLE `interface_release` (    `pub_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;Publish ID&#39;,    `pub_api_id`      int(11)      NOT NULL                  COMMENT &#39;所属API ID&#39;,    `pub_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,    `pub_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,    `pub_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0有效，1无效（可能被下线）&#39;,    `pub_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,    `pub_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,    `pub_script_ori`  mediumtext   NOT NULL                  COMMENT &#39;原始查询脚本，仅当类型为SQL时不同&#39;,    `pub_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,    `pub_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,    `pub_release_time`datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;发布时间（下线不更新）&#39;,    PRIMARY KEY (`pub_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway API 发布历史。&#39;;create index idx_interface_release on interface_release (pub_api_id);</code></pre><h4 id="将Datasource注入Hasor容器"><a href="#将Datasource注入Hasor容器" class="headerlink" title="将Datasource注入Hasor容器"></a>将Datasource注入Hasor容器</h4><ul><li>在项目目录下建一个<code>hasor目录</code></li></ul><pre><code class="java">package xxx.hasor;import net.hasor.core.ApiBinder;import net.hasor.core.DimModule;import net.hasor.db.JdbcModule;import net.hasor.db.Level;import net.hasor.spring.SpringModule;import org.springframework.stereotype.Component;import javax.annotation.Resource;import javax.sql.DataSource;/** * @author : eyestarrysky * @date : Created in 2020/5/1 */@DimModule@Componentpublic class HasorModule implements SpringModule {    @Resource    private DataSource dataSource;    @Override    public void loadModule(ApiBinder apiBinder) throws Throwable {        apiBinder.installModule(new JdbcModule(Level.Full, this.dataSource));    }}</code></pre><h4 id="SpringBoot启动类开启Hasor注解"><a href="#SpringBoot启动类开启Hasor注解" class="headerlink" title="SpringBoot启动类开启Hasor注解"></a>SpringBoot启动类开启Hasor注解</h4><pre><code class="java">package xxx;import net.hasor.spring.boot.EnableHasor;import net.hasor.spring.boot.EnableHasorWeb;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@EnableHasor@EnableHasorWeb@SpringBootApplicationpublic class DatawayApplication {    public static void main(String[] args) {        SpringApplication.run(DatawayApplication.class, args);    }}</code></pre><h4 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h4><pre><code class="verilog"> _    _                        ____              _| |  | |                      |  _ \            | || |__| | __ _ ___  ___  _ __  | |_) | ___   ___ | |_|  __  |/ _` / __|/ _ \| &#39;__| |  _ &lt; / _ \ / _ \| __|| |  | | (_| \__ \ (_) | |    | |_) | (_) | (_) | |_|_|  |_|\__,_|___/\___/|_|    |____/ \___/ \___/ \__|</code></pre><ul><li>项目启动成功，访问<code>http://localhost:8080/interface-ui/</code>即可</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>接口面板</li></ul><p><img src="http://qiniu.eyestarrysky.top/dataway-console.png" alt="找不到"></p><ul><li>新增接口，右边几个按钮分别为<code>save</code>，<code>execute</code>, <code>test</code>, <code>publish</code></li></ul><p><img src="http://qiniu.eyestarrysky.top/dataway-new-interface.png" alt="找不到"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用jetcache来操作缓存</title>
    <link href="/2020/04/27/%E4%BD%BF%E7%94%A8jetcache%E6%9D%A5%E6%93%8D%E4%BD%9C%E7%BC%93%E5%AD%98/"/>
    <url>/2020/04/27/%E4%BD%BF%E7%94%A8jetcache%E6%9D%A5%E6%93%8D%E4%BD%9C%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h3 id="Jetcache前言"><a href="#Jetcache前言" class="headerlink" title="Jetcache前言"></a>Jetcache前言</h3><ul><li><code>git</code>地址:  <a href="https://github.com/alibaba/jetcache/" target="_blank" rel="noopener">https://github.com/alibaba/jetcache/</a></li></ul><p>​        <strong>因为之前项目的原因接触过jecache，但是没有好好整理，今天闲下来，悉心整理了下，并看了下文档，学了下自动刷新缓存，感觉这个挺适合用来更新首页轮播图，通栏的。</strong></p><h3 id="基本配置（Spring-Boot"><a href="#基本配置（Spring-Boot" class="headerlink" title="基本配置（Spring Boot)"></a>基本配置（Spring Boot)</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><pre><code class="xml">&lt;!-- jetCache  --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;    &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><pre><code class="yml">#jetcache# @see com.alicp.jetcache.autoconfigure.JetCachePropertiesjetcache:  # 统计间隔，默认0：表示不统计  statIntervalMinutes: 1  # areaName是否作为缓存key前缀，默认True  areaInCacheName: false  local:    default:      # 已支持可选：linkedhashmap、caffeine      type: linkedhashmap      # key转换器的全局配置，当前只有：fastjson, @see com.alicp.jetcache.support.FastjsonKeyConvertor      keyConvertor: fastjson      # 每个缓存实例的最大元素的全局配置，仅local类型的缓存需要指定      limit: 100      # jetcache2.2以上，以毫秒为单位，指定多长时间没有访问，就让缓存失效，当前只有本地缓存支持。0表示不使用这个功能，指定30秒后失效      expireAfterAccessInMillis: 30000  remote:    default:      type: redis      keyConvertor: fastjson      valueEncoder: java      valueDecoder: java      poolConfig:        minIdle: 5        maxIdle: 20        maxTotal: 50      host: ${redis.host}      port: 6379      password: ${redis.password}</code></pre><h5 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h5><pre><code class="java">@SpringBootApplication@EnableMethodCache(basePackages = &quot;com.company.mypackagee&quot;)@EnableCreateCacheAnnotationpublic class Application extends SpringBootServletInitializer {    public static void main(String[] args) {        SpringApplication.run(Application.class);    }}</code></pre><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li><p>下面例子以操作<code>User</code>为例<br><code>user.java</code></p><pre><code class="java">@TableName(value = &quot;user&quot;)@Datapublic class User implements Serializable {    private static final long serialVersionUID = 738881519595997996L;    /**主键**/    @NotNull(message = &quot;主键不能为空&quot;)    private Long id;    /**姓名**/    @NotBlank(message = &quot;名字不能为空&quot;)    @Length(min = 1, message = &quot;名字至少1个字&quot;)    private String name;    /**手机号**/    @NotBlank(message = &quot;手机号不能为空&quot;)    @Size(max = 11, message = &quot;手机号最长11位&quot;)    @Pattern(regexp = &quot;^1\\d+$&quot;, message = &quot;手机号格式不正确&quot;)    private String phone;    /**电子邮件**/    @NotBlank(message = &quot;邮箱不能为空&quot;)    @Email(message = &quot;电子邮件格式不正确&quot;)    @Length(max = 30, message = &quot;邮箱长度不能超过30!&quot;)    private String email;    /**自我介绍**/    private String aboutme;    /**加密密码**/    private String passwd;    /**头像图片**/    private String avatar;    /**1:普通用户，2:房产经纪人**/    private Integer type;    /**创建时间**/    private Date createTime;    /**是否启用,1启用，0停用**/    private Integer enable;    /**所属经纪机构**/    private Integer agencyId;}</code></pre></li></ul><h4 id="基于注解实现方法缓存"><a href="#基于注解实现方法缓存" class="headerlink" title="基于注解实现方法缓存"></a>基于注解实现方法缓存</h4><h5 id="Cached：创建缓存"><a href="#Cached：创建缓存" class="headerlink" title="@Cached：创建缓存"></a>@Cached：创建缓存</h5><pre><code class="java">/** * 基于注解创建缓存 * 缓存在 Remote 的 Redis，也可以配置成 both 开启两级缓存 */@Cached(name = CACHE_NAME, key = &quot;#userId&quot;, cacheType = CacheType.LOCAL, expire = 5 * 60)@CacheRefresh(refresh = 60)public UserVO findUserById(Long userId) {    User user = userMapper.selectOne(queryWrapper);    //.....................}</code></pre><h5 id="CacheInvalidate：删除缓存"><a href="#CacheInvalidate：删除缓存" class="headerlink" title="@CacheInvalidate：删除缓存"></a>@CacheInvalidate：删除缓存</h5><pre><code class="java">@CacheInvalidate(name = CACHE_NAME, key = &quot;#userId&quot;)@Transactional(rollbackFor = Exception.class)public int deleteUserById(Long userId) {    User user = new User();    user.setId(userId);    user.setEnable(0);    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();    updateWrapper.lambda().eq(User::getId, userId).eq(User::getEnable, 1);    return userMapper.update(user, updateWrapper);}</code></pre><h5 id="CacheUpdate：更新缓存"><a href="#CacheUpdate：更新缓存" class="headerlink" title="@CacheUpdate：更新缓存"></a>@CacheUpdate：更新缓存</h5><pre><code class="java">/** * 更新用户 * @param user 用户 * @return int */@CacheUpdate(name = CACHE_NAME, key = &quot;#user.id&quot;, value = &quot;#user&quot;)public int updateUser(User user) {    log.info(&quot;【UserUpdate操作】, user = {}&quot;, JSON.toJSONString(user));    return userMapper.updateById(user);}</code></pre><h4 id="基于-CreateCache注解创建Cache实例"><a href="#基于-CreateCache注解创建Cache实例" class="headerlink" title="基于@CreateCache注解创建Cache实例"></a>基于@CreateCache注解创建Cache实例</h4><h5 id="CreateCache"><a href="#CreateCache" class="headerlink" title="@CreateCache"></a>@CreateCache</h5><pre><code class="java">/** * 使用 @CreateCache 注解创建Cache实例; * 未定义默认值的参数，将使用yml中指定的全局配置; * 缓存在 Local，也可以配置成 both 开启两级缓存 */@CreateCache(name = CACHE_NAME, expire = 5 * 60, localLimit = 10, cacheType = CacheType.LOCAL)private Cache&lt;Long, UserVO&gt; userCache;</code></pre><h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><pre><code class="java">public UserVO getUserByIdAndCreateCache(Long userId) {    //根据id从缓存中取    UserVO userVO = userCache.get(userId);    log.info(&quot;userCreateCache get {} res {}&quot;, userId, userCache);    if (Objects.isNull(userVO)) {        User user = userMapper.selectById(userId);        if (Objects.nonNull(user)) {            userVO = new UserVO();            BeanUtils.copyProperties(user, userVO);            //如果不存在就放入缓存中            boolean res = userCache.putIfAbsent(user.getId(), userVO);            log.info(&quot;userCreateCache putIfAbsent {} res {}&quot;, userId, res);        }    }    return userVO;}</code></pre><h5 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h5><pre><code class="java">@Transactional(rollbackFor = Exception.class)public int deleteUserByIdAndCreateCache(Long userId) {    User user = new User();    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();    updateWrapper.lambda().eq(User::getId, userId).eq(User::getEnable, 1);    user.setId(userId);    user.setEnable(0);    int result = userMapper.update(user, updateWrapper);    if (result &gt; 0) {        //根据key = userId删除缓存        boolean deleteResult = userCache.remove(userId);        log.info(&quot;同步删除缓存, userId = {}, res = {}&quot;, userId, deleteResult);    }    return result;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jetcache</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用github和hexo快速搭建个人博客</title>
    <link href="/2020/04/17/%E5%88%A9%E7%94%A8github%E5%92%8Chexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/04/17/%E5%88%A9%E7%94%A8github%E5%92%8Chexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p><code>git</code>下载地址：<code>http://gitforwindows.org</code></p><h4 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><p> <code>node.js</code> 下载地址：<code>http://nodejs.org/en/</code> </p><h3 id="二、本地搭建"><a href="#二、本地搭建" class="headerlink" title="二、本地搭建"></a>二、本地搭建</h3><ul><li><p>选择一个文件夹建一个目录<code>blog</code>存放博客相关文件，文件夹内右键打开<code>git bash here</code>，在窗口中执行以下所有命令</p></li><li><p>用<code>npm</code>安装<code>hexo</code>，由于国内网络高“墙”深院，避免安装缓慢或失败，这里切换阿里的<code>NPM</code>镜像，没办法只能采用迂回战术了。</p></li></ul><pre><code class="sh">$ npm install -g cnpm --registry=http://registry.npm.taobao.org</code></pre><p>用 <code>cnpm</code> 安装 <code>hexo</code></p><pre><code class="sh">$ cnpm install -g hexo-cli$ cnpm install hexo --save##检查hexo是否安装成功$ hexo -v</code></pre><ul><li>在<code>blog</code>文件夹建一个<code>hexo</code>文件存放博客，进入也打开<code>git bash here</code></li></ul><pre><code class="sh">$ hexo init</code></pre><p>初始化成功后，<code>hexo文件</code>夹内会出现如下的文件：</p><p><code>node_modules</code>: 依赖包<br><code>public</code>：存放生成的页面<br><code>scaffolds</code>：生成文章的一些模板<br><code>source</code>：用来存放你的文章<br><code>themes</code>：放下下载的主题<br><code>_config.yml:</code> 博客的核心配置文件（设置主体、标题等属性）</p><ul><li><p>接着需要执行一下<code>cnpm install</code>命令，要不下边的启动会提示命令不合法。</p></li><li><p>最后使用<code>hexo s -g</code>启动安装好的<code>hexo</code></p></li></ul><h3 id="三、托管至GitHub"><a href="#三、托管至GitHub" class="headerlink" title="三、托管至GitHub"></a>三、托管至GitHub</h3><ul><li><p>建立一个仓库，名称为<code>xxx.github.io</code></p></li><li><p>配置<code>_config.xml</code>文件，添加<code>GitHub</code>地址</p></li></ul><pre><code class="yml">deploy:  type: git  repo: https://github.com/xxx/xxx.github.io.git  branch: master</code></pre><ul><li>安装部署命令<code>deploy-git</code> ，这样你才能用命令部署到<code>GitHub</code></li></ul><pre><code class="sh">$ cnpm install hexo-deployer-git  --save</code></pre><ul><li>安装好后，依次执行下列命令，提交本地<code>hexo</code>文件到<code>GitHub</code></li></ul><pre><code class="sh">$ hexo clean$ hexo generate$ hexo deploy</code></pre><ul><li>最后访问<code>https://xxx.github.io.git</code>即可</li></ul><h3 id="四、选择自己喜欢的主题"><a href="#四、选择自己喜欢的主题" class="headerlink" title="四、选择自己喜欢的主题"></a>四、选择自己喜欢的主题</h3><ul><li><p>到<code>http://hexo.io/themes/</code>下载主题，<code>git clone</code>到本地</p><p><code>git clone https://github.com/iissnan/hexo-theme-next</code></p></li><li><p>修改<code>hexo</code>文件夹下的<code>_config.yml</code>文件中的<code>theme</code>属性</p></li></ul><pre><code class="yml">theme: hexo-theme-next</code></pre><ul><li>再次打包上传即可<pre><code class="sh">$ hexo clean$ hexo generate$ hexo deploy</code></pre></li></ul><h3 id="五、Hexo基本操作"><a href="#五、Hexo基本操作" class="headerlink" title="五、Hexo基本操作"></a>五、Hexo基本操作</h3><p>博客文章都放在<code>source\_post</code>目录下</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
      <category>建站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
