<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="eyestarrysky">
  <meta name="keywords" content="">
  <title>AQS结构及源码解析 - 眼底星空</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>眼底星空</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期六, 四月 4日 2020, 3:59 下午
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    4.1k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                    
                    
                    54
                     分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <h2 id="AQS（AbstaractQueuedSynchronize）"><a href="#AQS（AbstaractQueuedSynchronize）" class="headerlink" title="AQS（AbstaractQueuedSynchronize）"></a>AQS（AbstaractQueuedSynchronize）</h2><blockquote>
<p>AQS支持两种方式: 1,独占式 2.共享式</p>
</blockquote>
<pre><code class="java">//AQS定义的以下可重写的方法：

1. protected boolean tryAcquire(int arg) 
//独占式获取同步状态，试着获取，成功返回true，反之为false

2. protected boolean tryRelease(int arg) 
//独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；

3. protected int tryAcquireShared(int arg) 
//共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；

4. protected boolean tryReleaseShared(int arg) 
//共享式释放同步状态，成功为true，失败为false

5. protected boolean isHeldExclusively()
//是否在独占模式下被线程占用。
</code></pre>
<h3 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h3><pre><code class="java">public class MyExclusiveLock {

    private final static int LOCK_HOLD_STATE = 1;

    private final static int LOCK_RELEASE_STATE = 0;

    private final Sync sync = new Sync();

    /**
     * 如果当前锁为0(释放状态)，则加锁
     */
    public void lock() {
        sync.acquire(LOCK_HOLD_STATE);
    }

    /**
     * 如果当前锁状态为1(独占)，则设置为0(释放),否则报错
     */
    public void unLock() {
        sync.release(LOCK_HOLD_STATE);
    }

    public boolean isLocked() {
        return sync.isHeldExclusively();
    }

    private static class Sync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            //首先判断状态是否等于=0,如果状态==0，就将status设置为1
            if (compareAndSetState(LOCK_RELEASE_STATE, LOCK_HOLD_STATE)) {
                //将当前线程赋值给独占模式的owner
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            if (getState() == LOCK_RELEASE_STATE) {
                throw new IllegalMonitorStateException();
            }
            setExclusiveOwnerThread(null);
            setState(LOCK_RELEASE_STATE);
            return true;
        }


        @Override
        protected boolean isHeldExclusively() {
            return getState() == LOCK_HOLD_STATE;
        }
    }


    private static CyclicBarrier barrier = new CyclicBarrier(31);

    private static int count;

    private static final MyExclusiveLock myLock = new MyExclusiveLock();

    public static void main(String[] args) throws Exception {
        for (int i = 0; i &lt; 30; i++) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 10000; j++) {
                    incrementUnSync();
                }
                try {
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
        barrier.await();
        System.out.println(&quot;没有加锁，count=&quot; + count);

        //加锁后
        barrier.reset();
        count = 0;
        for (int i = 0; i &lt; 30; i++) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 10000; j++) {
                    incrementUseLock();
                }
                try {
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
        barrier.await();
        System.out.println(&quot;加锁后，count=&quot; + count);
    }

    /**
     * 不使用同步机制自增
     */
    public static void incrementUnSync() {
        count++;
    }

    /**
     * 使用我们实现的锁
     */
    public static void incrementUseLock() {
        myLock.lock();
        count++;
        myLock.unLock();
    }
}
</code></pre>
<h3 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h3><blockquote>
<p>AQS的实现依赖内部的同步队列（FIFO双向队列），如果当前线程获取同步状态失败，AQS会将该线程以及等待状态等信息构造成一个Node，将其加入同步队列的尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点。</p>
</blockquote>
<p><img src="http://q7g5kgqmj.bkt.clouddn.com/AQS1.png" alt="AQS1"></p>
<h4 id="获取同步状态"><a href="#获取同步状态" class="headerlink" title="获取同步状态"></a>获取同步状态</h4><blockquote>
<p>假设线程A要获取同步状态（这里想象成锁，方便理解），初始状态下state=0,所以线程A可以顺利获取锁，A获取锁后将state置为1。在A没有释放锁期间，线程B也来获取锁，此时因为state=1，表示锁被占用，所以将B的线程信息和等待状态等信息构成出一个Node节点对象，放入同步队列，head和tail分别指向队列的头部和尾部（此时队列中有一个空的Node节点作为头点，head指向这个空节点，空Node的后继节点是B对应的Node节点，tail指向它），同时阻塞线程B(这里的阻塞使用的是LockSupport.park()方法)。后续如果再有线程要获取锁，都会加入队列尾部并阻塞。</p>
</blockquote>
<h4 id="释放同步状态"><a href="#释放同步状态" class="headerlink" title="释放同步状态"></a>释放同步状态</h4><blockquote>
<p>当线程A释放锁时，即将state置为0，此时A会唤醒头节点的后继节点（所谓唤醒，其实是调用LockSupport.unpark(B)方法），即B线程从LockSupport.park()方法返回，此时B发现state已经为0，所以B线程可以顺利获取锁，B获取锁后B的Node节点随之出队。</p>
</blockquote>
<h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><blockquote>
<p>Node结点是AbstractQueuedSynchronizer中的一个静态内部类.</p>
</blockquote>
<pre><code class="java">static final class Node {
    /** waitStatus值，表示线程已被取消（等待超时或者被中断）*/
    static final int CANCELLED = 1;
    /** waitStatus值，表示线程需要被唤醒（unpaking）*/
    static final int SIGNAL = -1;
    //waitStatus值，表示结点线程等待在condition上，当被signal后，会从等待队列转移到同步队列中/
    static final int CONDITION = -2;
    /** waitStatus值，表示下一次共享式同步状态会被无条件地传播下去**/
    static final int PROPAGATE = -3;
     /** 等待状态，初始为0 */
    volatile int waitStatus;
    /**当前结点的前驱结点 */
    volatile Node prev;
    /** 当前结点的后继结点 */
    volatile Node next;
    /** 与当前结点关联的排队中的线程 */
    volatile Thread thread;
}</code></pre>
<h4 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h4><p>ConditionObject实现接口Condition，先看看属性</p>
<pre><code class="java">//等待队列中的首节点
private transient Node firstWaiter;
//等待队列中的尾节点
private transient Node lastWaiter;</code></pre>
<h5 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h5><pre><code class="java">//返回当前线程（状态设置好的）
private Node addConditionWaiter() {
    //获取等待队列中的尾节点
    Node t = lastWaiter;
    //尾节点失效的情况
    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
        //从头节点开始剔除节点
        unlinkCancelledWaiters();
        t = lastWaiter;
    }
    //将当前线程的状态设为Condition
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}</code></pre>
<h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><pre><code class="java">public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
     //将当前线程封装成Node加入到等待队列尾部
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    //如果当前线程不在同步队列上，就将其阻塞
    //其他线程如果发出了signal信号之后，会把等待队列的线程移入同步队列，此时就会退出循环，进入下面的重新获取锁的acquireQueued
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    //其他发出signal信号的线程释放锁之后，该线程被唤醒并重新竞争锁
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}</code></pre>
<h5 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h5><pre><code class="java">final boolean isOnSyncQueue(Node node) {
        if (node.waitStatus == Node.CONDITION || node.prev == null)
            return false;
        //如果有后继节点，且不为head节点说明在同步队列中
        if (node.next != null) // If has successor, it must be on queue
            return true;
        return findNodeFromTail(node);
    }</code></pre>
<pre><code class="java">private boolean findNodeFromTail(Node node) {
    //获取等待队列尾节点
    Node t = tail;
    for (;;) {
        //从尾节点向前遍历
        if (t == node)
            return true;
        if (t == null)
            return false;
        t = t.prev;
    }
}</code></pre>
<h5 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal"></a>doSignal</h5><pre><code class="java">do { //从等待队列的头节点的后继节点向后继节点进行遍历，如果该节点为null，则将尾节点置为null
    //否则，将该节点的后继节点置为null
    if ( (firstWaiter = first.nextWaiter) == null)
        lastWaiter = null;
    first.nextWaiter = null;
} while (!transferForSignal(first) &amp;&amp;
         (first = firstWaiter) != null);</code></pre>
<h5 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h5><pre><code class="java">private void unlinkCancelledWaiters() {
    //获取等待队列中的头结点
    Node t = firstWaiter;
    Node trail = null;
     //头节点不为空时，从头节点开始向后剔除节点
    while (t != null) {
        Node next = t.nextWaiter;
        if (t.waitStatus != Node.CONDITION) {
            t.nextWaiter = null;
            if (trail == null)
                firstWaiter = next;
            else
                trail.nextWaiter = next;
            if (next == null)
                lastWaiter = trail;
        }
        else
            trail = t;
        t = next;
    }
}</code></pre>
<h4 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h4><p><strong>调用lock()方法时一般会直接代理到acquire方法</strong></p>
<pre><code class="java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

//等同于
public final void acquire(int arg) {
    //1.尝试获取锁，获取到直接结束。否则执行2
    boolean hasAcquired = tryAcquire(arg);
    //2.将当前线程构建成一个独占的Node节点
    Node currentThreadNode = addWaiter(Node.EXCLUSIVE);
    //3.尝试获取当前线程的同步状态，如果获取不到则阻塞队列，直到被前驱或者后继节点唤醒
    boolean interrupted = acquireQueued(currentThreadNode, arg);
    if (interrupted) {
       selfInterrupt(); 
    }
}</code></pre>
<h5 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h5><p><strong>再来看看addWaiter的实现</strong></p>
<pre><code class="java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    //尾节点不为null时，AQS操作将node放入队尾
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    //尾节点为null时直接入队
    enq(node);
    return node;
}

//再来看看入队方法
private Node enq(final Node node) {
    //死循环（无锁，利用cas防止创建多个同步队列）
    for (;;) {
        //尾节点为null时初始化（延迟加载，好腻害）
        Node t = tail;
        if (t == null) { // Must initialize
            //cas操作创建头节点
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            //cas操作放入队尾
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>
<h5 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h5><pre><code class="java"> final boolean acquireQueued(final Node node, int arg) {
     boolean failed = true;
     try {
         boolean interrupted = false;
         //死循环
         for (;;) {
             //找到当前结点的前驱结点
             final Node p = node.predecessor();
             //如果前驱结点是头结点，才tryAcquire，其他结点是没有机会tryAcquire的。
             if (p == head &amp;&amp; tryAcquire(arg)) {
                 //获取同步状态成功，将当前结点设置为头结点。
                 setHead(node);
                 //方便GC
                 p.next = null; 
                 failed = false;
                 return interrupted;
             }
             // 如果没有获取到同步状态，通过shouldParkAfterFailedAcquire判断是否应该阻塞，parkAndCheckInterrupt用来阻塞线程
             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                 parkAndCheckInterrupt())
                 interrupted = true;
         }
     } finally {
         if (failed)
             cancelAcquire(node);
     }
 }</code></pre>
<blockquote>
<p>可以看到，acquireQueued方法也是一个死循环，直到进入 if (p == head &amp;&amp; tryAcquire(arg))条件方法块。还是接着刚才的操作来分析。acquireQueued接收的参数是addWaiter方法的返回值。node.predecessor()返回当前节点的前置节点，在这里也就是head节点，所以p==head成立，进而进行tryAcquire操作，即争用锁, 如果获取成功，则进入if方法体，看下接下来的操作：</p>
<p>1) 将当前节点设置为头节点。<br>2) 将当前节点的前置节点设置的next设置为null。</p>
<p>上面操作即完成了FIFO的出队操作。<br>从上面的分析可以看出，只有队列的第二个节点可以有机会争用锁，如果成功获取锁，则此节点晋升为头节点。对于第三个及以后的节点，if (p == head)条件不成立，首先进行shouldParkAfterFailedAcquire(p, node)操作（争用锁失败的第二个节点也如此.</p>
</blockquote>
<h5 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h5><p><code>shouldParkAfterFailedAcquire方法是判断一个争用锁的线程是否应该被阻塞</code></p>
<pre><code class="java">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        //获取前驱节点的等待状态
        int ws = pred.waitStatus;
        //如果后继节点需要被唤醒
        if (ws == Node.SIGNAL)
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
            return true;                                                                       if (ws &gt; 0) {
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
                //只有CANCEL状态ws才大于0。若前驱结点处于CANCEL状态，也就是此结点线程已经无效，从后往前遍历，找到一个非CANCEL状态的结点，将自己设置为它的后继结点
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don&#39;t park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            // 若前驱结点为其他状态，将其设置为SIGNAL状态
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }</code></pre>
<blockquote>
<p>shouldParkAfterFailedAcquire方法是判断一个争用锁的线程是否应该被阻塞。它首先判断一个节点的前置节点的状态是否为Node.SIGNAL，如果是，是说明此节点已经将状态设置，如果锁释放，则应当通知它，所以它可以安全的阻塞了，返回true。</p>
<p>如果前节点的状态大于0，即为CANCELLED状态时，则会从前节点开始逐步循环找到一个没有被“CANCELLED”节点设置为当前节点的前节点，返回false。在下次循环执行shouldParkAfterFailedAcquire时，返回true。这个操作实际是把队列中CANCELLED的节点剔除掉。</p>
<p>如果shouldParkAfterFailedAcquire返回了true，则会执行：“parkAndCheckInterrupt()”方法，它是通过LockSupport.park(this)将当前线程挂起到WATING状态，它需要等待一个中断、unpark方法来唤醒它，通过这样一种FIFO的机制的等待，来实现了Lock的操作。</p>
</blockquote>
<pre><code class="java">    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }</code></pre>
<h5 id="release"><a href="#release" class="headerlink" title="release"></a>release</h5><p><strong>当前线程执行完自己的逻辑之后，需要释放同步状态，来看看release方法的逻辑:</strong></p>
<pre><code class="java">public final boolean release(int arg) {
    //调用使用者重写的tryRelease方法，若成功，唤醒其后继结点，失败则返回false
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            //唤醒后继结点
            unparkSuccessor(h);
        return true;
    }
    return false;
}</code></pre>
<p><strong>在方法unparkSuccessor(Node)中，就意味着真正要释放锁了，它传入的是head节点（head节点是占用锁的节点），看下源码：</strong></p>
<pre><code class="java">private void unparkSuccessor(Node node) {
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        int ws = node.waitStatus;
        if (ws &lt; 0)
            // 将等待状态waitStatus设置为初始值0
            compareAndSetWaitStatus(node, ws, 0);

        /*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         */
        Node s = node.next;
    //若后继结点为空，或状态为CANCEL（已失效），则从后尾部往前遍历找到一个处于正常阻塞状态的结点进行唤醒
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        }
        if (s != null)
            //使用LockSupprot唤醒结点对应的线程
            LockSupport.unpark(s.thread);
    }</code></pre>
<p><strong>内部首先会发生的动作是获取head节点的next节点，如果获取到的节点不为空，则直接通过：“LockSupport.unpark()”方法来释放对应的被挂起的线程，这样一来将会有一个节点唤醒后继续进入循环进一步尝试tryAcquire()方法来获取锁。</strong></p>
<h4 id="共享式源码简单分析"><a href="#共享式源码简单分析" class="headerlink" title="共享式源码简单分析"></a>共享式源码简单分析</h4><blockquote>
<p>共享式：共享式地获取同步状态。对于独占式同步组件来讲，同一时刻只有一个线程能获取到同步状态，其他线程都得去排队等待，其待重写的尝试获取同步状态的方法tryAcquire返回值为boolean，这很容易理解；对于共享式同步组件来讲，同一时刻可以有多个线程同时获取到同步状态，这也是“共享”的意义所在。其待重写的尝试获取同步状态的方法tryAcquireShared返回值为int。</p>
</blockquote>
<pre><code class="java">protected int tryAcquireShared(int arg) {
    throw new UnsupportedOperationException();
}</code></pre>
<p>​    <strong>1.当返回值大于0时，表示获取同步状态成功，同时还有剩余同步状态可供其他线程获取；</strong></p>
<p>　　<strong>2.当返回值等于0时，表示获取同步状态成功，但没有可用同步状态了；</strong></p>
<p>　　<strong>3.当返回值小于0时，表示获取同步状态失败。</strong></p>
<h5 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared　"></a>acquireShared　</h5><pre><code class="java">public final void acquireShared(int arg) {
    //返回值小于0，获取同步状态失败，排队去；获取同步状态成功，直接返回去干自己的事儿。
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}</code></pre>
<h5 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h5><pre><code class="java">private void doAcquireShared(int arg) {
    //构造一个共享结点，添加到同步队列尾部。若队列初始为空，先添加一个无意义的傀儡结点，再将新节点添加到队列尾部。
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        //线程parking过程中是否被中断过
        boolean interrupted = false;
        for (;;) {
            //获取前驱
            final Node p = node.predecessor();
            //头结点持有同步状态，只有前驱是头结点，才有机会尝试获取同步状态
            if (p == head) {
                //尝试获取同步状态
                int r = tryAcquireShared(arg);
                if (r &gt;= 0) {
                    //获取成功就将当前结点设置为头结点，若还有可用资源，传播下去，也就是继续唤醒后继结
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            // 如果没有获取到同步状态，通过shouldParkAfterFailedAcquire判断是否应该阻塞，parkAndCheckInterrupt用来阻塞线程
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}</code></pre>
<p><strong>大体逻辑与独占式的acquireQueued差距不大，只不过由于是共享式，会有多个线程同时获取到线程，也可能同时释放线程，空出很多同步状态，所以当排队中的老二获取到同步状态，如果还有可用资源，会继续传播下去。</strong></p>
<pre><code class="java">private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node);
    //propagate&gt;0即同步状态成功，且可供后续获取,waitStatus&lt;0即之前的头节点被终止
    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
        (h = head) == null || h.waitStatus &lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}</code></pre>
<h5 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h5><pre><code class="java">private void doReleaseShared() {
        for (;;) {
            //死循环，共享模式，持有同步状态的线程可能有多个，采用循环CAS保证线程安全
            Node h = head;
            if (h != null &amp;&amp; h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    //唤醒后继结点
                    unparkSuccessor(h);
                }
                else if (ws == 0 &amp;&amp;
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
    }</code></pre>
<p><strong>代码逻辑比较容易理解，需要注意的是，共享模式，释放同步状态也是多线程的，此处采用了CAS自旋来保证。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong><font style="color:red">AQS是JUC中很多同步组件的构建基础，简单来讲，它内部实现主要是状态变量state和一个FIFO队列来完成，同步队列的头结点是当前获取到同步状态的结点，获取同步状态state失败的线程，会被构造成一个结点（或共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会阻塞；释放时唤醒头结点的后继结点，使其加入对同步状态的争夺中。</font></strong></p>

            </div>
            <hr>
            <div>
              <p>
                
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                  </div>
                </div>
              
            </div>

              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>




  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>








<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').each(function () {
        const pre = $(this);
        if (pre.find('code.mermaid').length > 0) {
          return;
        }
        pre.addClass('prettyprint  linenums');
      });
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "AQS结构及源码解析&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
